module esm_time_mod

  use shr_kind_mod        , only : cx=>shr_kind_cx, cs=>shr_kind_cs, cl=>shr_kind_cl, r8=>shr_kind_r8
  use ESMF                , only : ESMF_GridComp, ESMF_GridCompGet, ESMF_GridCompSet
  use ESMF                , only : ESMF_Clock, ESMF_ClockCreate, ESMF_ClockGet, ESMF_ClockSet
  use ESMF                , only : ESMF_ClockAdvance
  use ESMF                , only : ESMF_Alarm, ESMF_AlarmCreate, ESMF_AlarmGet
  use ESMF                , only : ESMF_Calendar, ESMF_CalKind_Flag, ESMF_CalendarCreate
  use ESMF                , only : ESMF_CALKIND_NOLEAP, ESMF_CALKIND_GREGORIAN
  use ESMF                , only : ESMF_Time, ESMF_TimeGet, ESMF_TimeSet
  use ESMF                , only : ESMF_TimeInterval, ESMF_TimeIntervalSet, ESMF_TimeIntervalGet
  use ESMF                , only : ESMF_SUCCESS, ESMF_LogWrite, ESMF_LOGMSG_INFO, ESMF_FAILURE
  use ESMF                , only : ESMF_VM, ESMF_VMGet, ESMF_VMBroadcast
  use ESMF                , only : ESMF_LOGMSG_INFO, ESMF_FAILURE
  use ESMF                , only : operator(<), operator(/=), operator(+)
  use ESMF                , only : operator(-), operator(*) , operator(>=)
  use ESMF                , only : operator(<=), operator(>), operator(==)
  use NUOPC               , only : NUOPC_CompAttributeGet
  use med_utils_mod       , only : chkerr => med_utils_ChkErr
  use med_time_mod        , only : med_time_alarmInit

  implicit none
  private    ! default private

  public  :: esm_time_clockInit  ! initialize driver clock (assumes default calendar)

  private :: esm_time_timeInit
  private :: esm_time_date2ymd

  ! Clock and alarm options
  character(len=*), private, parameter :: &
       optNONE           = "none"      , &
       optNever          = "never"     , &
       optNSteps         = "nsteps"    , &
       optNSeconds       = "nseconds"  , &
       optNMinutes       = "nminutes"  , &
       optNHours         = "nhours"    , &
       optNDays          = "ndays"     , &
       optNMonths        = "nmonths"   , &
       optNYears         = "nyears"    , &
       optMonthly        = "monthly"   , &
       optYearly         = "yearly"    , &
       optDate           = "date"      , &
       optGLCCouplingPeriod = "glc_coupling_period"

  ! Module data
  integer, parameter          :: SecPerDay = 86400 ! Seconds per day
  character(len=*), parameter :: u_FILE_u = &
       __FILE__

!===============================================================================
contains
!===============================================================================

  subroutine esm_time_clockInit(ensemble_driver, esmdriver, logunit, rc)

    ! input/output variables
    type(ESMF_GridComp)  :: ensemble_driver, esmdriver
    integer, intent(in)  :: logunit
    integer, intent(out) :: rc

    ! local variables
    type(ESMF_Clock)        :: clock
    type(ESMF_VM)           :: vm
    type(ESMF_Time)         :: StartTime           ! Start time
    type(ESMF_Time)         :: RefTime             ! Reference time
    type(ESMF_Time)         :: CurrTime            ! Current time
    type(ESMF_Time)         :: StopTime            ! Stop time
    type(ESMF_Time)         :: StopTime1           ! Stop time
    type(ESMF_Time)         :: StopTime2           ! Stop time
    type(ESMF_Time)         :: Clocktime           ! Loop time
    type(ESMF_TimeInterval) :: TimeStep            ! Clock time-step
    type(ESMF_Alarm)        :: alarm_stop          ! alarm
    integer                 :: ref_ymd             ! Reference date (YYYYMMDD)
    integer                 :: ref_tod             ! Reference time of day (seconds)
    integer                 :: start_ymd           ! Start date (YYYYMMDD)
    integer                 :: start_tod           ! Start time of day (seconds)
    integer                 :: curr_ymd            ! Current ymd (YYYYMMDD)
    integer                 :: curr_tod            ! Current tod (seconds)
    integer                 :: stop_n              ! Number until stop
    integer                 :: stop_ymd            ! Stop date (YYYYMMDD)
    integer                 :: stop_tod            ! Stop time-of-day
    character(CS)           :: stop_option         ! Stop option units
    integer                 :: atm_cpl_dt          ! Atmosphere coupling interval
    integer                 :: lnd_cpl_dt          ! Land coupling interval
    integer                 :: ice_cpl_dt          ! Sea-Ice coupling interval
    integer                 :: ocn_cpl_dt          ! Ocean coupling interval
    integer                 :: glc_cpl_dt          ! Glc coupling interval
    integer                 :: rof_cpl_dt          ! Runoff coupling interval
    integer                 :: wav_cpl_dt          ! Wav coupling interval
    integer                 :: esp_cpl_dt          ! Esp coupling interval
    character(CS)           :: glc_avg_period      ! Glc avering coupling period
    logical                 :: read_restart
    character(len=CL)       :: restart_file
    character(len=CL)       :: restart_pfile
    character(len=CL)       :: cvalue
    integer                 :: dtime_drv           ! time-step to use
    integer                 :: yr, mon, day, sec   ! Year, month, day, secs as integers
    integer                 :: localPet            ! local pet in esm domain
    logical                 :: mastertask          ! true if mastertask in esm domain
    integer                 :: unitn               ! unit number
    integer                 :: ierr                ! Return code
    character(CL)           :: tmpstr              ! temporary
    character(CS)           :: inst_suffix
    integer                 :: tmp(6)              ! Array for Broadcast
    logical                 :: isPresent
    character(len=*), parameter :: subname = '(esm_time_clockInit): '
    !-------------------------------------------------------------------------------

    rc = ESMF_SUCCESS

    call ESMF_GridCompGet(esmdriver, vm=vm, rc=rc)
    if (ChkErr(rc,__LINE__,u_FILE_u)) return
    ! We may want to get the ensemble_driver vm here instead so that
    ! files are read on global task 0 only instead of each esm member task 0
    call ESMF_VMGet(vm, localPet=localPet, rc=rc)
    if (ChkErr(rc,__LINE__,u_FILE_u)) return

    mastertask = localPet == 0

    !---------------------------------------------------------------------------
    ! Determine start time, reference time and current time
    !---------------------------------------------------------------------------

    curr_ymd = 0
    curr_tod = 0

    call NUOPC_CompAttributeGet(esmdriver, name="start_ymd", value=cvalue, rc=rc)
    if (ChkErr(rc,__LINE__,u_FILE_u)) return
    read(cvalue,*) start_ymd
    call NUOPC_CompAttributeGet(esmdriver, name="start_tod", value=cvalue, rc=rc)
    if (ChkErr(rc,__LINE__,u_FILE_u)) return
    read(cvalue,*) start_tod

    call NUOPC_CompAttributeGet(esmdriver, name="ref_ymd", value=cvalue, rc=rc)
    if (ChkErr(rc,__LINE__,u_FILE_u)) return
    read(cvalue,*) ref_ymd
    call NUOPC_CompAttributeGet(esmdriver, name="ref_tod", value=cvalue, rc=rc)
    if (ChkErr(rc,__LINE__,u_FILE_u)) return
    read(cvalue,*) ref_tod

    call NUOPC_CompAttributeGet(esmdriver, name='read_restart', value=cvalue, rc=rc)
    if (ChkErr(rc,__LINE__,u_FILE_u)) return
    read(cvalue,*) read_restart

    if (read_restart) then
       call NUOPC_CompAttributeGet(esmdriver, name='restart_file', value=restart_file, rc=rc)
       if (ChkErr(rc,__LINE__,u_FILE_u)) return

       !--- read rpointer if restart_file is set to str_undefined ---
       if (trim(restart_file) == 'str_undefined') then
          call NUOPC_CompAttributeGet(esmdriver, name="inst_suffix", isPresent=isPresent, rc=rc)
          if (ChkErr(rc,__LINE__,u_FILE_u)) return
          if(isPresent) then
             call NUOPC_CompAttributeGet(esmdriver, name="inst_suffix", value=inst_suffix, rc=rc)
             if (ChkErr(rc,__LINE__,u_FILE_u)) return
          else
             inst_suffix = ""
          endif
          restart_pfile = "rpointer.cpl"//inst_suffix
          if (mastertask) then
             call ESMF_LogWrite(trim(subname)//" read rpointer file = "//trim(restart_pfile), &
                  ESMF_LOGMSG_INFO)
             open(newunit=unitn, file=restart_pfile, form='FORMATTED', status='old',iostat=ierr)
             if (ierr < 0) then
                rc = ESMF_FAILURE
                call ESMF_LogWrite(trim(subname)//' ERROR rpointer file open returns error', &
                     ESMF_LOGMSG_INFO, line=__LINE__, file=__FILE__)
                return
             end if
             read(unitn,'(a)', iostat=ierr) restart_file
             if (ierr < 0) then
                rc = ESMF_FAILURE
                call ESMF_LogWrite(trim(subname)//' ERROR rpointer file read returns error', &
                     ESMF_LOGMSG_INFO, line=__LINE__, file=__FILE__)
                return
             end if
             close(unitn)
             call ESMF_LogWrite(trim(subname)//" read driver restart from file = "//trim(restart_file), &
                  ESMF_LOGMSG_INFO)
          endif
       endif
       if (mastertask) then
          call esm_time_read_restart(restart_file, &
               start_ymd, start_tod, ref_ymd, ref_tod, curr_ymd, curr_tod, rc)
          if (ChkErr(rc,__LINE__,u_FILE_u)) return
       endif
       tmp(1) = start_ymd
       tmp(2) = start_tod
       tmp(3) = ref_ymd
       tmp(4) = ref_tod
       tmp(5) = curr_ymd
       tmp(6) = curr_tod
       call ESMF_VMBroadcast(vm, tmp, 6, 0, rc=rc)
       if (ChkErr(rc,__LINE__,u_FILE_u)) return
       start_ymd = tmp(1)
       start_tod = tmp(2)
       ref_ymd = tmp(3)
       ref_tod = tmp(4)
       curr_ymd = tmp(5)
       curr_tod = tmp(6)
    end if

    if ( ref_ymd == 0 ) then
       ref_ymd = start_ymd
       ref_tod = start_tod
    endif
    if ( curr_ymd == 0 ) then
       curr_ymd = start_ymd
       curr_tod = start_tod
    endif

    ! Determine start time (THE FOLLOWING ASSUMES THAT THE DEFAULT CALENDAR IS SET in the driver)

    call esm_time_date2ymd(start_ymd, yr, mon, day)
    call ESMF_TimeSet( StartTime, yy=yr, mm=mon, dd=day, s=start_tod, rc=rc)
    if (ChkErr(rc,__LINE__,u_FILE_u)) return

    if(mastertask) then
       write(tmpstr,'(i10)') start_ymd
       call ESMF_LogWrite(trim(subname)//': driver start_ymd: '// trim(tmpstr), ESMF_LOGMSG_INFO)
       write(logunit,*)   trim(subname)//': driver start_ymd: '// trim(tmpstr)
       write(tmpstr,'(i10)') start_tod
       call ESMF_LogWrite(trim(subname)//': driver start_tod: '// trim(tmpstr), ESMF_LOGMSG_INFO)
       write(logunit,*)   trim(subname)//': driver start_tod: '// trim(tmpstr)
    endif

    ! Determine reference time
    call esm_time_date2ymd(ref_ymd, yr, mon, day)
    call ESMF_TimeSet( RefTime, yy=yr, mm=mon, dd=day, s=ref_tod, rc=rc)
    if (ChkErr(rc,__LINE__,u_FILE_u)) return

    if(mastertask) then
       write(tmpstr,'(i10)') ref_ymd
       call ESMF_LogWrite(trim(subname)//': driver ref_ymd: '// trim(tmpstr), ESMF_LOGMSG_INFO)
       write(logunit,*)   trim(subname)//': driver ref_ymd: '// trim(tmpstr)
       write(tmpstr,'(i10)') ref_tod
       call ESMF_LogWrite(trim(subname)//': driver ref_tod: '// trim(tmpstr), ESMF_LOGMSG_INFO)
       write(logunit,*)   trim(subname)//': driver ref_tod: '// trim(tmpstr)
    endif

    ! Determine current time
    call esm_time_date2ymd(curr_ymd, yr, mon, day)
    call ESMF_TimeSet( CurrTime, yy=yr, mm=mon, dd=day, s=curr_tod, rc=rc)
    if (ChkErr(rc,__LINE__,u_FILE_u)) return

    if(mastertask) then
       write(tmpstr,'(i10)') curr_ymd
       call ESMF_LogWrite(trim(subname)//': driver curr_ymd: '// trim(tmpstr), ESMF_LOGMSG_INFO)
       write(logunit,*)   trim(subname)//': driver curr_ymd: '// trim(tmpstr)
       write(tmpstr,'(i10)') curr_tod
       call ESMF_LogWrite(trim(subname)//': driver curr_tod: '// trim(tmpstr), ESMF_LOGMSG_INFO)
       write(logunit,*)   trim(subname)//': driver curr_tod: '// trim(tmpstr)
    endif

    !---------------------------------------------------------------------------
    ! Determine driver clock timestep
    !---------------------------------------------------------------------------

    call NUOPC_CompAttributeGet(esmdriver, name="atm_cpl_dt", value=cvalue, rc=rc)
    if (ChkErr(rc,__LINE__,u_FILE_u)) return
    read(cvalue,*) atm_cpl_dt

    call NUOPC_CompAttributeGet(esmdriver, name="lnd_cpl_dt", value=cvalue, rc=rc)
    if (ChkErr(rc,__LINE__,u_FILE_u)) return
    read(cvalue,*) lnd_cpl_dt

    call NUOPC_CompAttributeGet(esmdriver, name="ice_cpl_dt", value=cvalue, rc=rc)
    if (ChkErr(rc,__LINE__,u_FILE_u)) return
    read(cvalue,*) ice_cpl_dt

    call NUOPC_CompAttributeGet(esmdriver, name="ocn_cpl_dt", value=cvalue, rc=rc)
    if (ChkErr(rc,__LINE__,u_FILE_u)) return
    read(cvalue,*) ocn_cpl_dt

    call NUOPC_CompAttributeGet(esmdriver, name="glc_cpl_dt", value=cvalue, rc=rc)
    if (ChkErr(rc,__LINE__,u_FILE_u)) return
    read(cvalue,*) glc_cpl_dt

    call NUOPC_CompAttributeGet(esmdriver, name="rof_cpl_dt", value=cvalue, rc=rc)
    if (ChkErr(rc,__LINE__,u_FILE_u)) return
    read(cvalue,*) rof_cpl_dt

    call NUOPC_CompAttributeGet(esmdriver, name="wav_cpl_dt", value=cvalue, rc=rc)
    if (ChkErr(rc,__LINE__,u_FILE_u)) return
    read(cvalue,*) wav_cpl_dt

    call NUOPC_CompAttributeGet(esmdriver, name="glc_avg_period", value=glc_avg_period, rc=rc)
    if (ChkErr(rc,__LINE__,u_FILE_u)) return
    read(cvalue,*) glc_avg_period

    dtime_drv = minval((/atm_cpl_dt, lnd_cpl_dt, ocn_cpl_dt, ice_cpl_dt, glc_cpl_dt, rof_cpl_dt, wav_cpl_dt/))
    if(mastertask) then
       write(tmpstr,'(i10)') dtime_drv
       call ESMF_LogWrite(trim(subname)//': driver time interval is : '// trim(tmpstr), ESMF_LOGMSG_INFO, rc=rc)
       write(logunit,*)   trim(subname)//': driver time interval is : '// trim(tmpstr)
    endif
    call ESMF_TimeIntervalSet( TimeStep, s=dtime_drv, rc=rc )
    if (ChkErr(rc,__LINE__,u_FILE_u)) return

    !---------------------------------------------------------------------------
    ! Create the driver clock with an artificial stop time
    !---------------------------------------------------------------------------

    ! Create the clock
    clock = ESMF_ClockCreate(TimeStep, StartTime, refTime=RefTime, name='ESMF Driver Clock', rc=rc)
    if (ChkErr(rc,__LINE__,u_FILE_u)) return

    ! Advance the clock to the current time (in case of a restart)
    call ESMF_ClockGet(clock, currTime=clocktime, rc=rc )
    if (ChkErr(rc,__LINE__,u_FILE_u)) return
    do while( clocktime < CurrTime)
       call ESMF_ClockAdvance( clock, rc=rc )
       if (ChkErr(rc,__LINE__,u_FILE_u)) return
       call ESMF_ClockGet( clock, currTime=clocktime, rc=rc )
       if (ChkErr(rc,__LINE__,u_FILE_u)) return
    end do

    ! Set the driver gridded component clock to the created clock
    call ESMF_GridCompSet(esmdriver, clock=clock, rc=rc)
    if (ChkErr(rc,__LINE__,u_FILE_u)) return

    ! Set driver clock stop time
    call NUOPC_CompAttributeGet(esmdriver, name="stop_option", value=stop_option, rc=rc)
    if (ChkErr(rc,__LINE__,u_FILE_u)) return
    call NUOPC_CompAttributeGet(esmdriver, name="stop_n", value=cvalue, rc=rc)
    if (ChkErr(rc,__LINE__,u_FILE_u)) return
    read(cvalue,*) stop_n
    call NUOPC_CompAttributeGet(esmdriver, name="stop_ymd", value=cvalue, rc=rc)
    if (ChkErr(rc,__LINE__,u_FILE_u)) return
    read(cvalue,*) stop_ymd
    call NUOPC_CompAttributeGet(esmdriver, name="stop_tod", value=cvalue, rc=rc)
    if (ChkErr(rc,__LINE__,u_FILE_u)) return
    read(cvalue,*) stop_tod
    if ( stop_ymd < 0) then
       stop_ymd = 99990101
       stop_tod = 0
    endif

    if (mastertask) then
       write(tmpstr,'(i10)') stop_ymd
       call ESMF_LogWrite(trim(subname)//': driver stop_ymd: '// trim(tmpstr), ESMF_LOGMSG_INFO)
       write(logunit,*)   trim(subname)//': driver stop_ymd: '// trim(tmpstr)
       write(tmpstr,'(i10)') stop_tod
       call ESMF_LogWrite(trim(subname)//': driver stop_tod: '// trim(tmpstr), ESMF_LOGMSG_INFO)
       write(logunit,*)   trim(subname)//': driver stop_tod: '// trim(tmpstr)
    endif

    call med_time_alarmInit(clock, &
         alarm   = alarm_stop,           &
         option  = stop_option,          &
         opt_n   = stop_n,               &
         opt_ymd = stop_ymd,             &
         opt_tod = stop_tod,             &
         RefTime = CurrTime,             &
         alarmname = 'alarm_stop', rc=rc)
    if (ChkErr(rc,__LINE__,u_FILE_u)) return

    call ESMF_AlarmGet(alarm_stop, RingTime=StopTime, rc=rc )
    if (ChkErr(rc,__LINE__,u_FILE_u)) return

    call ESMF_ClockSet(clock, StopTime=StopTime, rc=rc)
    if (ChkErr(rc,__LINE__,u_FILE_u)) return

    !---------------------------------------------------------------------------
    ! Create the ensemble driver clock
    !---------------------------------------------------------------------------

    TimeStep = StopTime - ClockTime
    clock = ESMF_ClockCreate(TimeStep, ClockTime, StopTime=StopTime, &
         refTime=RefTime, name='ESMF ensemble Driver Clock', rc=rc)
    if (ChkErr(rc,__LINE__,u_FILE_u)) return
    call ESMF_GridCompSet(ensemble_driver, clock=clock, rc=rc)
    if (ChkErr(rc,__LINE__,u_FILE_u)) return

 end subroutine esm_time_clockInit

 !===============================================================================

 subroutine esm_time_timeInit( Time, ymd, cal, tod, desc, logunit )

   !  Create the ESMF_Time object corresponding to the given input time, given in
   !  YMD (Year Month Day) and TOD (Time-of-day) format.
   !  Set the time by an integer as YYYYMMDD and integer seconds in the day

   ! input/output parameters:
   type(ESMF_Time)     , intent(inout)        :: Time ! ESMF time
   integer             , intent(in)           :: ymd  ! year, month, day YYYYMMDD
   type(ESMF_Calendar) , intent(in)           :: cal  ! ESMF calendar
   integer             , intent(in), optional :: tod  ! time of day in seconds
   character(len=*)    , intent(in), optional :: desc ! description of time to set
   integer             , intent(in), optional :: logunit

   ! local variables
   integer                     :: yr, mon, day ! Year, month, day as integers
   integer                     :: ltod         ! local tod
   character(len=256)          :: ldesc        ! local desc
   integer                     :: rc           ! return code
   character(len=*), parameter :: subname = '(esm_time_m_ETimeInit) '
   !-------------------------------------------------------------------------------

   ltod = 0
   if (present(tod)) ltod = tod
   ldesc = ''
   if (present(desc)) ldesc = desc

   if ( (ymd < 0) .or. (ltod < 0) .or. (ltod > SecPerDay) )then
      if (present(logunit)) then
         write(logunit,*) subname//': ERROR yymmdd is a negative number or '// &
              'time-of-day out of bounds', ymd, ltod
      end if
      call ESMF_LogWrite( subname//'ERROR: Bad input' , ESMF_LOGMSG_INFO)
      rc = ESMF_FAILURE
      return
   end if

   call esm_time_date2ymd (ymd,yr,mon,day)

   call ESMF_TimeSet( Time, yy=yr, mm=mon, dd=day, s=ltod, calendar=cal, rc=rc )
   if (ChkErr(rc,__LINE__,u_FILE_u)) return

 end subroutine esm_time_timeInit

 !===============================================================================

 subroutine esm_time_date2ymd (date, year, month, day)

   ! input/output variables
   integer, intent(in)  :: date             ! coded-date (yyyymmdd)
   integer, intent(out) :: year,month,day   ! calendar year,month,day

   ! local variables
   integer :: tdate   ! temporary date
   character(*),parameter :: subName = "(esm_time_date2ymd)"
   !-------------------------------------------------------------------------------

   tdate = abs(date)
   year = int(tdate/10000)
   if (date < 0) then
      year = -year
   end if
   month = int( mod(tdate,10000)/  100)
   day = mod(tdate,  100)

 end subroutine esm_time_date2ymd

 !===============================================================================

 subroutine esm_time_read_restart(restart_file, &
      start_ymd, start_tod, ref_ymd, ref_tod, curr_ymd, curr_tod, rc)

   use netcdf , only : nf90_open, nf90_nowrite, nf90_noerr
   use netcdf , only : nf90_inq_varid, nf90_get_var, nf90_close
   use ESMF   , only : ESMF_LogWrite, ESMF_LOGMSG_INFO

   ! input/output variables
   character(len=*), intent(in) :: restart_file
   integer, intent(out)         :: ref_ymd             ! Reference date (YYYYMMDD)
   integer, intent(out)         :: ref_tod             ! Reference time of day (seconds)
   integer, intent(out)         :: start_ymd           ! Start date (YYYYMMDD)
   integer, intent(out)         :: start_tod           ! Start time of day (seconds)
   integer, intent(out)         :: curr_ymd            ! Current ymd (YYYYMMDD)
   integer, intent(out)         :: curr_tod            ! Current tod (seconds)
   integer, intent(out)         :: rc

   ! local variables
   integer                 :: status, ncid, varid ! netcdf stuff
   character(CL)           :: tmpstr              ! temporary
   character(len=*), parameter :: subname = "(esm_time_read_restart)"
   !----------------------------------------------------------------

   ! use netcdf here since it's serial
   status = nf90_open(restart_file, NF90_NOWRITE, ncid)
   if (status /= nf90_NoErr) then
      print *,__FILE__,__LINE__,trim(restart_file)
      call ESMF_LogWrite(trim(subname)//' ERROR: nf90_open', ESMF_LOGMSG_INFO)
      rc = ESMF_FAILURE
      return
   endif
   status = nf90_inq_varid(ncid, 'start_ymd', varid)
   if (status /= nf90_NoErr) then
      call ESMF_LogWrite(trim(subname)//' ERROR: nf90_inq_varid start_ymd', ESMF_LOGMSG_INFO)
      rc = ESMF_FAILURE
      return
   end if
   status = nf90_get_var(ncid, varid, start_ymd)
   if (status /= nf90_NoErr) then
      call ESMF_LogWrite(trim(subname)//' ERROR: nf90_get_var start_ymd', ESMF_LOGMSG_INFO)
      rc = ESMF_FAILURE
      return
   end if
   status = nf90_inq_varid(ncid, 'start_tod', varid)
   if (status /= nf90_NoErr) then
      call ESMF_LogWrite(trim(subname)//' ERROR: nf90_inq_varid start_tod', ESMF_LOGMSG_INFO)
      rc = ESMF_FAILURE
      return
   end if
   status = nf90_get_var(ncid, varid, start_tod)
   if (status /= nf90_NoErr) then
      call ESMF_LogWrite(trim(subname)//' ERROR: nf90_get_var start_tod', ESMF_LOGMSG_INFO)
      rc = ESMF_FAILURE
      return
   end if
   status = nf90_inq_varid(ncid, 'ref_ymd', varid)
   if (status /= nf90_NoErr) then
      call ESMF_LogWrite(trim(subname)//' ERROR: nf90_inq_varid ref_ymd', ESMF_LOGMSG_INFO)
      rc = ESMF_FAILURE
      return
   end if
   status = nf90_get_var(ncid, varid, ref_ymd)
   if (status /= nf90_NoErr) then
      call ESMF_LogWrite(trim(subname)//' ERROR: nf90_get_var ref_ymd', ESMF_LOGMSG_INFO)
      rc = ESMF_FAILURE
      return
   end if
   status = nf90_inq_varid(ncid, 'ref_tod', varid)
   if (status /= nf90_NoErr) then
      call ESMF_LogWrite(trim(subname)//' ERROR: nf90_inq_varid ref_tod', ESMF_LOGMSG_INFO)
      rc = ESMF_FAILURE
      return
   end if
   status = nf90_get_var(ncid, varid, ref_tod)
   if (status /= nf90_NoErr) then
      call ESMF_LogWrite(trim(subname)//' ERROR: nf90_get_var ref_tod', ESMF_LOGMSG_INFO)
      rc = ESMF_FAILURE
      return
   end if
   status = nf90_inq_varid(ncid, 'curr_ymd', varid)
   if (status /= nf90_NoErr) then
      call ESMF_LogWrite(trim(subname)//' ERROR: nf90_inq_varid curr_ymd', ESMF_LOGMSG_INFO)
      rc = ESMF_FAILURE
      return
   end if
   status = nf90_get_var(ncid, varid, curr_ymd)
   if (status /= nf90_NoErr) then
      call ESMF_LogWrite(trim(subname)//' ERROR: nf90_get_var curr_ymd', ESMF_LOGMSG_INFO)
      rc = ESMF_FAILURE
      return
   end if
   status = nf90_inq_varid(ncid, 'curr_tod', varid)
   if (status /= nf90_NoErr) then
      call ESMF_LogWrite(trim(subname)//' ERROR: nf90_inq_varid curr_tod', ESMF_LOGMSG_INFO)
      rc = ESMF_FAILURE
      return
   end if
   status = nf90_get_var(ncid, varid, curr_tod)
   if (status /= nf90_NoErr) then
      call ESMF_LogWrite(trim(subname)//' ERROR: nf90_get_var curr_tod', ESMF_LOGMSG_INFO)
      rc = ESMF_FAILURE
      return
   end if
   status = nf90_close(ncid)
   if (status /= nf90_NoErr) then
      call ESMF_LogWrite(trim(subname)//' ERROR: nf90_close', ESMF_LOGMSG_INFO)
      rc = ESMF_FAILURE
      return
   end if

   write(tmpstr,*) trim(subname)//" read start_ymd = ",start_ymd
   call ESMF_LogWrite(trim(tmpstr), ESMF_LOGMSG_INFO)
   write(tmpstr,*) trim(subname)//" read start_tod = ",start_tod
   call ESMF_LogWrite(trim(tmpstr), ESMF_LOGMSG_INFO)
   write(tmpstr,*) trim(subname)//" read ref_ymd   = ",ref_ymd
   call ESMF_LogWrite(trim(tmpstr), ESMF_LOGMSG_INFO)
   write(tmpstr,*) trim(subname)//" read ref_tod   = ",ref_tod
   call ESMF_LogWrite(trim(tmpstr), ESMF_LOGMSG_INFO)
   write(tmpstr,*) trim(subname)//" read curr_ymd  = ",curr_ymd
   call ESMF_LogWrite(trim(tmpstr), ESMF_LOGMSG_INFO)
   write(tmpstr,*) trim(subname)//" read curr_tod  = ",curr_tod
   call ESMF_LogWrite(trim(tmpstr), ESMF_LOGMSG_INFO)

 end subroutine esm_time_read_restart

end module esm_time_mod
